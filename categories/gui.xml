<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dan Yeaw's Blog (Posts about GUI)</title><link>https://dan.yeaw.me/</link><description></description><atom:link href="https://dan.yeaw.me/categories/gui.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2022 &lt;a href="mailto:dan@yeaw.me"&gt;Dan Yeaw&lt;/a&gt; </copyright><lastBuildDate>Sun, 23 Jan 2022 21:36:00 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>5 Steps to Build Python Native GUI Widgets for BeeWare</title><link>https://dan.yeaw.me/posts/gui-widget-for-beeware/</link><dc:creator>Dan Yeaw</dc:creator><description>&lt;p&gt;Part of my work at Ford Motor Company is to use Model-Based Systems Engineering
through languages like SysML to help design safety in to complex automated
and electrified technologies. In my free time I took over maintaining a UML
tool called &lt;a href="https://github.com/gaphor/gaphor"&gt;Gaphor&lt;/a&gt; with the aim of
eventually turning it in to a simple SysML tool for beginners. I'm sure I'll
be writing about this much more in the future.&lt;/p&gt;
&lt;p&gt;Eventually I got really frustrated with the current set of GUI toolkits that
are available for Python. I want the ability to write an app once and have it
look and feel great on all of my devices, but instead I was dealing with
toolkits that are wrapped or introspected around C or C++ libraries, or
visually look like a blast from past. They made me feel like I was going
against the grain of Python instead of writing great Pythonic code.&lt;/p&gt;
&lt;p&gt;If you haven't heard of BeeWare yet, it is a set of software libraries for
cross-platform native app development from a single Python codebase and tools
to simplify app deployment. When I say cross-platform and native, I mean truly
that. The project aims to build, deploy, and run apps for Windows, Linux, macOS, Android,
iPhone, and the web. It is native because it is actually that platform's native
GUI widgets, not a theme, icon pack, or webpage wrapper.&lt;/p&gt;
&lt;p&gt;A little over a year ago, I started to contribute to the BeeWare project. I
needed a canvas drawing widget for the app I am working on, I saw that this was
not supported by BeeWare, so I went ahead and created it. Based on my
experience, this blog post details how I would create a new widget from
scratch, now that I have done it before, with the hope that it helps you
implement your own widget as well.&lt;/p&gt;
&lt;p&gt;If you are new to BeeWare, I recommend to start out with the
&lt;a href="https://briefcase.readthedocs.io/en/latest/tutorial/index.html"&gt;Briefcase&lt;/a&gt; and
&lt;a href="https://toga.readthedocs.io/en/latest/tutorial/index.html"&gt;Toga&lt;/a&gt; Tutorials, and
then the &lt;a href="https://pybee.org/contributing/how/first-time/"&gt;First-time Contributor's Guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="BeeWare Logo with Brutus the Bee and text" src="https://dan.yeaw.me/images/beeware-logo.png"&gt;&lt;/p&gt;
&lt;p&gt;The current status of the BeeWare project, at the time of writing this, is that
it is a solid proof of concept. Creating a simple app on macOS, Linux, or iOS
is definitely possible. In fact there is an app called Travel Tips on Apple's
App Store that was created by Russell Keith-Magee as a demonstration. Support
for some of the other platforms like Windows and Android is lagging behind
some, so except some very rough edges.&lt;/p&gt;
&lt;p&gt;This alpha status may not be so exciting for you if you are just trying to
build an app, but I think it is &lt;strong&gt;very&lt;/strong&gt; exciting for those that want to
contribute to an open source project. Although there are many ways to get
involved, users keep asking how they can build a GUI widget that isn't yet
supported. I think this is a great way to make a significant contribution.&lt;/p&gt;
&lt;p&gt;A GUI widget forms the controls and logic that a user interacts with when using
a GUI. The BeeWare project uses a GUI widget toolkit called Toga, and below is
a view of what some of the widgets look like in Linux.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Example of Toga Widgets in a demo app" src="https://dan.yeaw.me/images/toga-widgets.png"&gt;  &lt;/p&gt;
&lt;p&gt;There are button, table, tree, and icon widgets in the example. Since I
contributed a canvas drawing widget, I will be using that for the example of
how you could contribute your own widget to the project.&lt;/p&gt;
&lt;p&gt;There are three internal layers that make up every widget:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;strong&gt;Interface&lt;/strong&gt; layer&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Implementation&lt;/strong&gt; layer&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Native&lt;/strong&gt; layer  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://dan.yeaw.me/images/toga-blackbox.svg" alt="Toga Blackbox" height="200"&gt;&lt;/p&gt;
&lt;p&gt;As the input to Toga, the Interface layer provides the public API for the GUI
application that you are building. This is the code you will type to build your
app using Toga.&lt;/p&gt;
&lt;p&gt;As the output of Toga, the Native layer connects the Toga_impl's to the Native
Platform. For C language based platforms, Toga directly calls the native
widgets. For example with Gtk+ on Linux, the Toga_gtk directly calls the Gtk+
widgets through PyGObject. For other platforms, more intermediate work may be
required through a bridge or transpiler:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS and iOS, the Rubicon-ObjC project provides a bridge between Objective-C and Python.&lt;/li&gt;
&lt;li&gt;Web, Batavia provides a javascript implementation of the Python virtual machine. &lt;/li&gt;
&lt;li&gt;Android, VOC is a transpiler that converts Python in to Java bytecode.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://dan.yeaw.me/images/toga-whitebox.svg" alt="Toga Whitebox" height="175"&gt;&lt;/p&gt;
&lt;p&gt;The Interface layer calls public methods that are in the Toga_core portion of
the project and this is where this Interface layer API is defined. Toga_core
also provides any abstract functionality that is independent of the platform
that Toga is running on, like setting up and running the app itself.&lt;/p&gt;
&lt;p&gt;The Implementation layer connects Toga_core to the Toga_impl component.&lt;/p&gt;
&lt;p&gt;A couple of other terms you should know about are &lt;code&gt;impl&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt;.
1. From Toga_core, &lt;code&gt;self.impl&lt;/code&gt; is used to go across the interface layer to
Toga_impl.
2. From Toga_impl, &lt;code&gt;self.interface&lt;/code&gt; is used to go across the interface layer
back to Toga_core.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://dan.yeaw.me/images/toga-impl-interface.svg" alt="More Terms" height="175"&gt;&lt;/p&gt;
&lt;p&gt;Toga uses the Factory Method design pattern in order to improve testability.
This pattern creates objects using a factory method instead of directly
calling a constructor. In Toga, this factory method is in Toga_core and it is
used to instantiate a platform backend as the Toga_impl like Toga_ios, Toga_cocoa
or Toga_gtk. The factory method automatically selects the correct backend based
on the &lt;code&gt;sys.platform&lt;/code&gt; of the platform it is running on.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://dan.yeaw.me/images/factory-pattern.svg" alt="Factory Method" height="300"&gt;&lt;/p&gt;
&lt;p&gt;Toga_dummy is also a type of Toga_impl backend, and it is used for smoke testing
without a specific platform to find simple failures. When tests are initialized,
Toga_dummy is passed in as the factory. This allows the tests and the creation
of objects to be separated which improves maintainability and makes the test
code easier to read.&lt;/p&gt;
&lt;p&gt;I know there is a lot there, but understanding the software architecture of
Toga together with the surrounding projects and interfaces will be key to
implementing your own widget. With that background information out of the way,
lets not delay any further, and jump in to building a widget.&lt;/p&gt;
&lt;h2&gt;Step 0&lt;/h2&gt;
&lt;h3&gt;Pick your development platform&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Normally pick the platform that you are most familiar with&lt;/li&gt;
&lt;li&gt;macOS and Gtk+ are the most developed :thumbsup:&lt;/li&gt;
&lt;li&gt;Is this a mobile only widget (camera, GPS, etc)?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This seems somewhat obvious, since the platform you select will most likely be
based on the laptop or other device you are using right now. But do consider
this. Most of my experience developing widgets are on Gtk+ and Cocoa so this is
where I am coming from. Implementing widgets on other platforms is definitely
needed as well, but it may be an additional challenge due to those platforms
not as well developed with Toga yet. These other platforms may be more
challenging, but they are also the areas where the BeeWare project needs the
most help, so if you have some experience with them or feel especially brave,
definitely go for it.&lt;/p&gt;
&lt;h2&gt;Step 1&lt;/h2&gt;
&lt;h3&gt;Research your widget&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Abstraction requires knowledge of specific examples&lt;/li&gt;
&lt;li&gt;Create use cases or user stories&lt;/li&gt;
&lt;li&gt;Get feedback&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since Toga is an abstraction of native GUI toolkits, understanding the APIs for
these platforms is extremely important in order to develop a well abstracted API
for Toga. In other words, these native platforms provide the inspiration and
constraints on implementing your own widget.&lt;/p&gt;
&lt;p&gt;As an example, of how you would conduct this research, this is how you would
draw a rectangle on a Canvas on different platforms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tkinter&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;canvas&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tk&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_rectangle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fill&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"red"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;wxpython&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_PAINT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OnPaint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnPaint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;dc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PaintDC&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;dc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBrush&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Brush&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Colour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="n"&gt;dc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DrawRectangle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;HTML canvas&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"myCanvas"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;ctx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"2d"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fillStyle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"rgb(200, 0, 0)"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fillRect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Gtk+&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;drawingarea&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Gtk&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DrawingArea&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;drawingarea&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"draw"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;draw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;draw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;da&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_source_rgb&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rectangle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fill&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The other thing to understand is how a user will use this widget to build their
own app. I like to create a quick Use Case diagram to flush this out, but you
could also use User Stories or similar methods.&lt;/p&gt;
&lt;p&gt;For the case of the Canvas widget, I came up with three main use cases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A simple drawing app, where a user adds shapes, colors, and text to the
   screen.&lt;/li&gt;
&lt;li&gt;A vectoring drawing app, where a user draws lines and shapes, and then needs
   the ability to edit the nodes of the lines.&lt;/li&gt;
&lt;li&gt;A platformer game, where there is a lot of objects draw on the screen,
   including the hero. The hero needs its own drawing context so that they can
   run, jump, and move around without unintentionally modifying the rest of the
   objects.  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://dan.yeaw.me/images/usecases.svg" alt="Use Cases" height="300"&gt;&lt;/p&gt;
&lt;p&gt;The last part of Step 1 is to get feedback. I recommend creating a GitHub Issue
or Draft Pull Request at this point and start to discuss the design of your
widget abstraction with others and continue that discussion as you design your
python API in step 2.&lt;/p&gt;
&lt;h2&gt;Step 2&lt;/h2&gt;
&lt;h3&gt;Write Docs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Write your API documentation first&lt;/li&gt;
&lt;li&gt;The API provides the set of clearly defined methods of communication (layers) between the software components&lt;/li&gt;
&lt;li&gt;Documentation Driven Development&lt;/li&gt;
&lt;li&gt;This is iterative with Step 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With your Use Cases from Step 1, start your docs by explaining what your widget
is and what it is used for. When looking at the Canvas widgets from my research,
I noticed that the current drawing widgets were very procedural, you have to
create your canvas drawing using many steps. For example, you have to first set
the color to draw with, then draw an object, and then fill in that object.&lt;/p&gt;
&lt;p&gt;Python has the context manager and the "with" statement, and making use of this
for a canvas allows the user to better break up the draw operations with some
nesting. It also allows for automatically starting or closing drawing of a
closed path for the user. This is an example of the types of things that you
can take advantage of in an API that was designed for Python. It is easy to try
to copy the API that you are familiar with, but I think you can really make
your widget stand out by taking a step back and looking at how you can make an
API that users will really enjoy using.&lt;/p&gt;
&lt;p&gt;Here is an example of writing the initial explanation and widget API for the
canvas widget:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;The canvas is used for creating a blank widget that you can
draw on.

&lt;span class="gu"&gt;Usage&lt;/span&gt;
&lt;span class="gu"&gt;--&lt;/span&gt;

Simple usage to draw a colored rectangle on the screen using
the arc drawing object:

import toga
canvas = toga.Canvas(style=Pack(flex=1))
with canvas.fill(color=rgb(200, 0, 0)) as fill:
    fill.rect(10, 10, 100, 100)
&lt;/pre&gt;
&lt;p&gt;Once that is complete, now might be a good time to ask for feedback to see if
you have missed any use cases or if others have any ideas of how to improve the
public API of the widget. One way to collect feedback would be to submit an
issue or a "work in progress" pull request to the &lt;a href="https://github.com/pybee/Toga"&gt;Toga
project&lt;/a&gt;, or ask for feedback on the &lt;a href="https://gitter.im/pybee/general"&gt;Gitter
channel&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Next, start to work out the structure of your Toga_core code based on your API.
I recommend creating the class and method definitions and add the docstrings to
outline what each portion of the software does and what arguments and return
values it provides. This is part of the overall documentation that will be
generated by Sphinx for your widget, and creating this before writing your code
will provide the next level of API documentation.&lt;/p&gt;
&lt;p&gt;Here is an example of how that structure and docstrings would look for a canvas
widget:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Canvas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""Create new canvas.&lt;/span&gt;

&lt;span class="sd"&gt;    Args:&lt;/span&gt;
&lt;span class="sd"&gt;        id (str):  An identifier for this widget.&lt;/span&gt;
&lt;span class="sd"&gt;        style (:obj:`Style`): An optional style object. &lt;/span&gt;
&lt;span class="sd"&gt;        factory (:obj:`module`): A python module that is&lt;/span&gt;
&lt;span class="sd"&gt;            capable to return a implementation of this class.&lt;/span&gt;

&lt;span class="sd"&gt;     """&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""Constructs and returns a :class:`Rect &amp;lt;Rect&amp;gt;`.&lt;/span&gt;

&lt;span class="sd"&gt;    Args:&lt;/span&gt;
&lt;span class="sd"&gt;        x (float): x coordinate for the rectangle.&lt;/span&gt;
&lt;span class="sd"&gt;        ...&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Step 3&lt;/h2&gt;
&lt;h3&gt;Implement your Toga_core widget using TDD&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Write a test for each function of the widget outlined in the API from Step 3&lt;/li&gt;
&lt;li&gt;Check that the tests fail&lt;/li&gt;
&lt;li&gt;Specify the implementation layer API&lt;/li&gt;
&lt;li&gt;Write the core code for the widget to call the implementation layer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Test Driven Development is a test-first technique to write your tests prior to
or in parallel with writing the software. I am being opinionated here,
because you don't have to write your code using this process. But, I think
this will really help you think about what you want from the code as you
implement these different API layers.&lt;/p&gt;
&lt;p&gt;Toga_core has a "tests" folder, and this is where you need to create your tests
for the widget. Sometimes it can be challenging to know what tests to write, but
in the previous step you already outlined what the use cases and scenarios are for
using your widget, and the API to make use of the widget. Break this up in to atomic
tests to check that you can successfully create the widget, and then make use of and
modify the widget using all of the outlined scenarios.&lt;/p&gt;
&lt;p&gt;Here is a test to check that the widget is created. The &lt;code&gt;canvas._impl.interface&lt;/code&gt;
is testing the call to the Toga_impl component ("_impl") and then back to the
Toga_core component ("interface"). In other words we are testing that the canvas object
is the same object as we go to the Implementation layer to the Toga_impl and
then back across the Implementation layer to the Toga_core. The object should be
equal as long as it was created successfully. The second line of the test
&lt;code&gt;assertActionPerformed&lt;/code&gt; is using the dummy backend to test that the canvas was
created, and I'll discuss that more in Step 4 below.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_widget_created&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;assertEqual&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_impl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assertActionPerformed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"create Canvas"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Further along in my test creation I also wanted to check that the user could modify
a widget that was already created. So I created a test that modifies the coordinates
and size of a rectangle. &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_rect_modify&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;rect&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
    &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;
    &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;
    &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;
    &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;redraw&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assertActionPerformedWith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"rect"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Once you are done creating your tests and make sure that they are failing as
expected, it is time to move on to filling in all of those Toga_core classes
and objects that you left blank in the previous step.&lt;/p&gt;
&lt;p&gt;Toga provides a base Widget class that all widgets derive from. It defines the
interface for core functionality for children, styling, layout and ownership by
specific App and Window. Below our class Canvas is derived from Widget and is
initialized:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Canvas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;As part of the class initialization, Toga also uses the factory method to
determine the correct Toga_impl platform, and then connect it from the
Toga_core to Toga_impl&lt;code&gt;self._impl&lt;/code&gt; and back the other way using
&lt;code&gt;interface=self&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;        &lt;span class="c1"&gt;# Create a platform specific implementation of Canvas&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_impl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Finally, we fill in our methods to call the creation of the rectangle on the
Toga_impl component using the Implementation layer:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_impl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Step 4&lt;/h2&gt;
&lt;h3&gt;Implement the Toga_impl widget on the dummy backend&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dummy is for automatic testing without a native platform&lt;/li&gt;
&lt;li&gt;Code the implementation layer API endpoint, create a method for each call of the API&lt;/li&gt;
&lt;li&gt;Check that all tests now pass&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When your widget is integrated with Toga, we want unit tests to run with the
test suite automatically during continuous integration. It may be difficult
during these tests to start up every platform and check that your widget is
working correctly, so there is a Toga_impl called dummy that doesn't require a
platform at all. This allows for smoke testing to make sure that the widget
correctly calling the Implementation layer API.&lt;/p&gt;
&lt;p&gt;Now go ahead and implement the Toga_impl widget on the dummy backend. There
needs to be methods for each call from the Toga_core to the Toga_impl. Below we
check that the Canvas create and rect method actions were invoked through
Implementation layer API calls.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Canvas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_action&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"create Canvas"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_action&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;"rect"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;You now should be able to run and pass all the tests that you created in Step 3.&lt;/p&gt;
&lt;h2&gt;Step 5&lt;/h2&gt;
&lt;h3&gt;Implement the Toga_impl widget on your platform backend&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Copy toga_dummy and create a new endpoint for the platform you chose in Step 1&lt;/li&gt;
&lt;li&gt;Make use of the native interface API for this widget on your platform&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If after your research in Step 1, you aren't feeling confident in how the widget
should work on your platform, now would be a good time to take a break to go
practice. Build a simple canvas drawing app for your platform using the native
widgets. Once you have done that, now is the time to create the Toga_impl for
your platform that calls those native widgets on your platform.&lt;/p&gt;
&lt;p&gt;In my example, Gtk+ uses an event callback to do native drawing. So I create a
Gtk.DrawingArea to draw on when my Canvas widget is created, and then I connect
that drawing callback to the gtk_draw_callback function which then calls a method
in Toga_core through the Implementation layer:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Canvas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;native&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Gtk&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DrawingArea&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;native&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;interface&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;interface&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;native&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"draw"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gtk_draw_callback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gtk_draw_callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gtk_context&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_draw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;draw_context&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;gtk_context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Some platforms like Android or Cocoa will require transpiling or bridging to
the native platform calls since those platforms using a different programming
language. This may require the creation of extra native objects to, for
example, reserve memory on those platforms. Here is an example of what this
extra TogaCanvas class would like with the Cocoa platform:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TogaCanvas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSView&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@objc_method&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;drawRect_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NSRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NSGraphicsContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;graphicsPort&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Finally create each method for your native implementation. Below we create an
implementation of the rectangle creation that calls Gtk+'s cairo drawing:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;draw_context&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;draw_context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rectangle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Iterate&lt;/h2&gt;
&lt;h4&gt;Iterate through steps 1-5 to complete your widget implementation&lt;/h4&gt;
&lt;p&gt;In the examples, we created a Canvas and a rectangle drawing operation on that
canvas. Now it is time to iterate back through all the steps and implement all
the other drawing operations that a Canvas needs like the other shapes, lines,
and text. Once you finish this, you should now have a complete widget!&lt;/p&gt;
&lt;p&gt;&lt;img alt="Toga Tutorial 4 for a Canvas Widget" src="https://dan.yeaw.me/images/tutorial-4.png"&gt;&lt;/p&gt;
&lt;p&gt;Tada! You did it, Submit a PR!&lt;/p&gt;
&lt;p&gt;I would be interested in how it goes for you, drop me a line with your
experience creating a widget.&lt;/p&gt;
&lt;p&gt;2018-11-10: Minor editorial updates.&lt;/p&gt;
&lt;p&gt;2019-04-27: Split Toga Architecture diagram up to make it more clear.&lt;/p&gt;
&lt;p&gt;2019-05-02: Improve description about research in Step 1. Add description of
&lt;code&gt;impl&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; in architecture section.&lt;/p&gt;</description><category>BeeWare</category><category>GUI</category><category>programming</category><category>Python</category><category>Toga</category><category>widget</category><guid>https://dan.yeaw.me/posts/gui-widget-for-beeware/</guid><pubDate>Sun, 04 Nov 2018 01:36:00 GMT</pubDate></item></channel></rss>